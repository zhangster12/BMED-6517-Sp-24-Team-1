function [new_gen, samples] = ...
    produceGeneration(old_gen, fitness, fit_rank, similarity, R, M, C, L, N)

% -------------------------------------------------------------------------
% This function produces a new generation of offspring from an original
% generation based on the fitness scores assigned to the original
% generation. Optionally, a single progenitor may be provided such that a
% generation may be produced by randomly combining alleles. Input
% parameters include:
% - old_gen     {Nx1}   Cell vector of N organisms - OR -
%               {nxm}   M vectors of N alleles for a single progenitor
% - fitness     [Nx1]   Fitness score vector for N organisms - OR -
%               []      Leave this blank to generate random generation
% - fit_rank    [Nx1]   Fitness ranks for each organism - OR -
%               []      Leave this blank to generate random generation
% - similarity  [NxN]   Matrix containing average euclidian distance of
%                       each organism to other organisms
% - R                   Population size of new generation (2^R)
% - M                   Mutation coefficient
% - C                   Crossover coefficient
% - L                   Progenitor limitation coefficient
% - N                   Niche penalty
% -------------------------------------------------------------------------

% Set placeholder for return values
new_gen = cell(2^R, 1);         % Cell array for offspring
samples = zeros(2^R, 1);        % Array for sampling frequency

% Repeat process for each offspring
for i = 1:length(new_gen)
    
    % If fitness scores are provided
    if ~isempty(fitness)
        
        % Limit breeding to top L organisms
        if ~strcmp(L, 'all')
            fitness(fit_rank(L+1:end)) = 0;     % Zero out unfit organisms
            fitness = fitness/norm(fitness, 1); % Normalize fitness
        end

        % Determine parents by sampling fitness as a PDF
        % Determine first parent with prior distribution
        % Arguments: userPDF, numSamples, Plot
        parents(1) = smart.general.samplePDF(fitness, 1, false);
        
        % Determine second parent with posterior distribution
        
        % The posterior distribution is generated by adjusting prior
        % distribution by the corresponding row in the similarity matrix.
        % The prior is multiplied by the similarity matrix before being
        % re-normalized such that the probability of selecting the second
        % parent is modified by its Euclidian distance to the first parent.
        raw_post = fitness.*(similarity(parents(1),:).^N)';
        posterior = raw_post/norm(raw_post, 1);
        parents(2) = smart.general.samplePDF(posterior, 1, false);
        
        parent_1 = old_gen{parents(1)};
        parent_2 = old_gen{parents(2)};

        % Mutate the chromosomes, then recombine
        mutated_1 = smart.genetic.mutate(parent_1, M);
        mutated_2 = smart.genetic.mutate(parent_2, M);

        % Recombine to produce offspring
        [new_gen{i}, ~] = smart.genetic.recombine(mutated_1, mutated_2, C);

        % Record samples
        samples(parents(1)) = samples(parents(1)) + 1;
        samples(parents(2)) = samples(parents(2)) + 1;
        
    else
        
        % If fitness scores are not provided, generate the new generation
        % at random from the template provided
        new_gen{i} = smart.genetic.shuffleAlleles(old_gen);
        
        % Sample data not available
        samples = [];
        
    end
    
end

end

